// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  // URL is configured in prisma.config.ts for Prisma 7+
}

// NextAuth required models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Core User model
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String? // Hashed password for email/password auth
  role          UserRole  @default(USER)
  handle        String?   @unique // Custom handle for profile URLs
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // NextAuth relations
  accounts Account[]
  sessions Session[]

  // Profile relations
  profile     UserProfile?
  experiences Experience[]
  educations  Education[]
  skills      UserSkill[]

  // Social relations
  connectionsAsRequester Connection[] @relation("ConnectionRequester")
  connectionsAsReceiver  Connection[] @relation("ConnectionReceiver")

  // Content relations
  posts         Post[]
  postReactions PostReaction[]
  comments      Comment[]
  reposts       Repost[]

  // Job relations
  jobsPosted   Job[]
  applications JobApplication[]

  // Group relations
  groupsOwned      Group[]
  groupMemberships GroupMembership[]
  groupPosts       GroupPost[]

  // Messaging
  messageThreadsAsUser1 MessageThread[] @relation("ThreadUser1")
  messageThreadsAsUser2 MessageThread[] @relation("ThreadUser2")
  messages              Message[]

  // Engagement Workflows
  createdWorkflows EngagementWorkflow[] @relation("WorkflowCreator")

  // Notifications
  notifications Notification[]

  // Candidates (added by admin)
  candidatesAdded Candidate[]

  // Referrals
  referralsMade Referral[] @relation("Referrer")

  @@index([email])
  @@index([handle])
}

enum UserRole {
  USER
  ADMIN
}

// User Profile (extended profile info)
model UserProfile {
  id          String   @id @default(cuid())
  userId      String   @unique
  headline    String?
  location    String?
  about       String?  @db.Text
  bannerImage String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Experience (work history)
model Experience {
  id          String    @id @default(cuid())
  userId      String
  title       String
  companyId   String?
  companyName String? // For non-company entries
  location    String?
  description String?   @db.Text
  startDate   DateTime
  endDate     DateTime?
  isCurrent   Boolean   @default(false)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  company Company? @relation("CompanyEmployees", fields: [companyId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([companyId])
}

// Education
model Education {
  id           String    @id @default(cuid())
  userId       String
  school       String
  degree       String?
  fieldOfStudy String?
  startDate    DateTime?
  endDate      DateTime?
  description  String?   @db.Text
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// Skills
model Skill {
  id        String   @id @default(cuid())
  name      String   @unique
  createdAt DateTime @default(now())

  users UserSkill[]
}

model UserSkill {
  id        String   @id @default(cuid())
  userId    String
  skillId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  skill Skill @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([userId, skillId])
  @@index([userId])
  @@index([skillId])
}

// Connections (Network)
model Connection {
  id          String           @id @default(cuid())
  requesterId String
  receiverId  String
  status      ConnectionStatus @default(PENDING)
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  requester User @relation("ConnectionRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  receiver  User @relation("ConnectionReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([requesterId, receiverId])
  @@index([requesterId])
  @@index([receiverId])
  @@index([status])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// Posts
model Post {
  id              String   @id @default(cuid())
  authorId        String
  content         String   @db.Text
  imageUrl        String?
  linkUrl         String?
  linkTitle       String?
  linkDescription String?  @db.Text
  linkImage       String?
  groupId         String? // If posted in a group
  companyId       String? // If tagged to a company
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  isActive        Boolean  @default(true)

  author    User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
  group     Group?         @relation(fields: [groupId], references: [id], onDelete: SetNull)
  company   Company?       @relation(fields: [companyId], references: [id], onDelete: SetNull)
  reactions PostReaction[]
  comments  Comment[]
  reposts   Repost[]

  @@index([authorId])
  @@index([groupId])
  @@index([companyId])
  @@index([createdAt])
}

// Post Reactions (Likes)
model PostReaction {
  id        String       @id @default(cuid())
  postId    String
  userId    String
  type      ReactionType @default(LIKE)
  createdAt DateTime     @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([postId])
  @@index([userId])
}

enum ReactionType {
  LIKE
  LOVE
  CELEBRATE
  SUPPORT
  FUNNY
  INSIGHTFUL
}

// Comments
model Comment {
  id        String   @id @default(cuid())
  postId    String
  authorId  String
  content   String   @db.Text
  parentId  String? // For nested comments (replies)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)

  post    Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  author  User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent  Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies Comment[] @relation("CommentReplies")

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
}

// Reposts
model Repost {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  content   String?  @db.Text // Optional commentary
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
}

// Companies
model Company {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  logo      String?
  banner    String?
  industry  String?
  size      String? // e.g., "1-10", "11-50", "51-200", etc.
  location  String?
  website   String?
  about     String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)

  employees Experience[] @relation("CompanyEmployees")
  jobs      Job[]
  posts     Post[]

  @@index([slug])
  @@index([name])
}

// Jobs
model Job {
  id             String         @id @default(cuid())
  title          String
  companyId      String
  postedById     String
  location       String?
  isRemote       Boolean        @default(false)
  isHybrid       Boolean        @default(false)
  employmentType EmploymentType
  salaryMin      Int?
  salaryMax      Int?
  salaryCurrency String?        @default("USD")
  description    String         @db.Text
  requirements   String?        @db.Text
  views          Int            @default(0)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  expiresAt      DateTime?
  isActive       Boolean        @default(true)

  company      Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  postedBy     User             @relation(fields: [postedById], references: [id], onDelete: Cascade)
  applications JobApplication[]
  referrals    Referral[]

  @@index([companyId])
  @@index([postedById])
  @@index([isActive])
  @@index([createdAt])
}

enum EmploymentType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
  TEMPORARY
}

// Job Applications
model JobApplication {
  id          String            @id @default(cuid())
  jobId       String
  applicantId String
  resumeUrl   String?
  coverLetter String?           @db.Text
  status      ApplicationStatus @default(APPLIED)
  notes       String?           @db.Text // For recruiter notes
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  job       Job  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  applicant User @relation(fields: [applicantId], references: [id], onDelete: Cascade)

  @@unique([jobId, applicantId])
  @@index([jobId])
  @@index([applicantId])
  @@index([status])
}

enum ApplicationStatus {
  APPLIED
  IN_REVIEW
  INTERVIEW
  OFFER
  REJECTED
}

// Groups (Community Boards)
model Group {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?  @db.Text
  coverImage  String?
  ownerId     String
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  isActive    Boolean  @default(true)

  owner       User              @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  memberships GroupMembership[]
  posts       Post[]
  groupPosts  GroupPost[]

  @@index([slug])
  @@index([ownerId])
}

model GroupMembership {
  id       String    @id @default(cuid())
  groupId  String
  userId   String
  role     GroupRole @default(MEMBER)
  joinedAt DateTime  @default(now())

  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
}

enum GroupRole {
  MEMBER
  MODERATOR
  ADMIN
}

// Group-specific posts (separate from main feed posts)
model GroupPost {
  id        String   @id @default(cuid())
  groupId   String
  authorId  String
  content   String   @db.Text
  imageUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  isActive  Boolean  @default(true)

  group  Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  author User  @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([groupId])
  @@index([authorId])
  @@index([createdAt])
}

// Messaging
model MessageThread {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user1    User      @relation("ThreadUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2    User      @relation("ThreadUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  messages Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
}

model Message {
  id            String   @id @default(cuid())
  threadId      String
  senderId      String
  content       String   @db.Text
  attachmentUrl String?
  isRead        Boolean  @default(false)
  createdAt     DateTime @default(now())

  thread MessageThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  sender User          @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([threadId])
  @@index([senderId])
  @@index([createdAt])
}

// Notifications
model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String           @db.Text
  link      String? // URL to navigate to
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}

enum NotificationType {
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  POST_LIKED
  POST_COMMENTED
  MESSAGE_RECEIVED
  JOB_APPLICATION_RECEIVED
  JOB_APPLICATION_UPDATED
  GROUP_INVITATION
  MENTION
}

// Candidates (scraped from LinkedIn via extension)
model Candidate {
  id                                String          @id @default(cuid())
  linkedinUrl                       String          @unique
  fullName                          String
  currentCompany                    String?
  currentCompanyStartDate           String?
  currentCompanyEndDate             String?
  currentCompanyTenureYears         String?
  currentCompanyTenureMonths        String?
  jobTitle                          String?
  location                          String?
  previousTargetCompany             String?
  previousTargetCompanyStartDate    String?
  previousTargetCompanyEndDate      String?
  previousTargetCompanyTenureYears  String?
  previousTargetCompanyTenureMonths String?
  tenurePreviousTarget              String?
  previousTitles                    String?         @db.Text
  totalYearsExperience              String?
  universities                      String?         @db.Text // JSON array as string
  fieldsOfStudy                     String?         @db.Text // JSON array as string
  degrees                           String?
  undergradGraduationYear           String?
  certifications                    String?         @db.Text
  languages                         String?         @db.Text
  projects                          String?         @db.Text
  publications                      String?         @db.Text
  volunteerOrganizations            String?         @db.Text
  courses                           String?         @db.Text
  honorsAwards                      String?         @db.Text
  organizations                     String?         @db.Text
  patents                           String?         @db.Text
  testScores                        String?         @db.Text
  emails                            String?         @db.Text
  phones                            String?         @db.Text
  socialLinks                       String?         @db.Text
  skillsCount                       Int?
  experienceCount                   Int?
  educationCount                    Int?
  companies                         String?         @db.Text // JSON array as string
  rawData                           String?         @db.Text // Full original JSON
  addedById                         String? // Admin who added this candidate
  status                            CandidateStatus @default(ACTIVE)
  notes                             String?         @db.Text // Admin notes
  // AI-generated fields
  aiSummary                         String?         @db.Text // AI-generated candidate summary
  aiKeyStrengths                    String?         @db.Text // JSON array of key strengths
  aiBestFitRoles                    String?         @db.Text // JSON array of best fit roles
  aiHighlights                      String?         @db.Text // Notable experience highlights
  aiConcerns                        String?         @db.Text // Potential concerns or gaps
  aiSummaryGeneratedAt              DateTime?       // When AI summary was generated
  // Predictive scoring fields
  predictiveScore                   Float?          // 0-100 success probability score
  scoreConfidence                   String?         // HIGH, MEDIUM, LOW
  scoreRiskFactors                  String?         @db.Text // JSON array of risk factors
  scoreGeneratedAt                  DateTime?       // When score was generated
  scoreJobId                        String?         // Score is job-specific
  createdAt                         DateTime        @default(now())
  updatedAt                         DateTime        @updatedAt

  addedBy User? @relation(fields: [addedById], references: [id], onDelete: SetNull)
  engagements Engagement[]
  referrals Referral[]

  @@index([linkedinUrl])
  @@index([fullName])
  @@index([currentCompany])
  @@index([jobTitle])
  @@index([status])
  @@index([createdAt])
}

enum CandidateStatus {
  ACTIVE
  ARCHIVED
  CONTACTED
  HIRED
  REJECTED
}

// Engagement Workflows
model EngagementWorkflow {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  steps       String   @db.Text // JSON array of workflow steps
  isActive    Boolean  @default(true)
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  createdBy User         @relation("WorkflowCreator", fields: [createdById], references: [id], onDelete: Cascade)
  engagements Engagement[]

  @@index([createdById])
  @@index([isActive])
}

enum EngagementType {
  EMAIL
  CALL
  MESSAGE
  LINKEDIN
  SMS
}

enum EngagementStatus {
  PENDING
  SCHEDULED
  SENT
  DELIVERED
  OPENED
  CLICKED
  RESPONDED
  FAILED
  CANCELLED
}

model Engagement {
  id          String   @id @default(cuid())
  candidateId String
  workflowId  String?
  type        EngagementType
  subject     String?  // For emails
  content     String?  @db.Text
  scheduledAt DateTime
  sentAt      DateTime?
  deliveredAt DateTime?
  openedAt    DateTime?
  clickedAt   DateTime?
  respondedAt DateTime?
  status      EngagementStatus @default(PENDING)
  metadata    String?  @db.Text // JSON for additional tracking data
  errorMessage String? @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  candidate Candidate          @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  workflow  EngagementWorkflow? @relation(fields: [workflowId], references: [id], onDelete: SetNull)

  @@index([candidateId])
  @@index([workflowId])
  @@index([status])
  @@index([scheduledAt])
  @@index([type])
}

// Tech Trends
model Trend {
  id           String   @id @default(cuid())
  title        String
  url          String   @unique
  source       String
  publishedAt  DateTime?
  highlight   String   @db.Text
  category    String
  rawExcerpt  String   @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@index([publishedAt])
  @@index([createdAt])
  @@index([url])
}

// Referral Network System
model Referral {
  id              String          @id @default(cuid())
  referrerId      String          // User who made the referral
  candidateId     String?         // If candidate exists in system
  candidateName   String          // Name of referred candidate
  candidateEmail  String?
  candidateLinkedInUrl String?
  jobId           String?         // Job they're being referred for
  status          ReferralStatus  @default(PENDING)
  notes           String?         @db.Text
  // Tracking
  submittedAt     DateTime        @default(now())
  contactedAt     DateTime?
  interviewedAt   DateTime?
  hiredAt        DateTime?
  rejectedAt      DateTime?
  // Rewards
  rewardStatus    RewardStatus    @default(PENDING)
  rewardAmount    Float?         // If monetary reward
  rewardNotes     String?         @db.Text
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  referrer User   @relation("Referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  candidate Candidate? @relation(fields: [candidateId], references: [id], onDelete: SetNull)
  job       Job?       @relation(fields: [jobId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([candidateId])
  @@index([jobId])
  @@index([status])
  @@index([submittedAt])
}

enum ReferralStatus {
  PENDING       // Just submitted
  CONTACTED     // Candidate was contacted
  INTERVIEWING  // In interview process
  HIRED         // Successfully hired
  REJECTED      // Not hired
  WITHDRAWN     // Referral withdrawn
}

enum RewardStatus {
  PENDING       // Reward not yet processed
  APPROVED      // Reward approved
  PAID          // Reward paid out
  DENIED        // Reward denied
}
